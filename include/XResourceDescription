#ifndef XRESOURCEDESCRIPTION_H
#define XRESOURCEDESCRIPTION_H

#include "XGlobal"
#include "XProperty"

namespace Eks
{

#define X_ALIGN_BYTE_COUNT 16

#define xAssertIsSpecificAligned(ptr, alignment) xAssert(Eks::isAligned(ptr, alignment), (xsize)ptr, alignment, ((xsize)(ptr)&(alignment-1)))
#define xAssertIsAligned(ptr) xAssertIsSpecificAligned(ptr, X_ALIGN_BYTE_COUNT)

template <typename T> struct AlignmentOf
  {
  enum
    {
    Alignment = std::alignment_of<T>::value
    };
  };

template <typename T> bool isAligned(T ptr, xsize alignment = X_ALIGN_BYTE_COUNT)
  {
  const xptrdiff bitmask = (xptrdiff)alignment - 1;
  const xsize ptrD = (xsize)ptr;

  return (ptrD&bitmask) == 0;
  }

template <typename T> T offsetBy(T d, xptrdiff by)
  {
  return (T)((xuint8*)d + by);
  }

template <typename T> inline T roundToAlignment(T exp, xsize alignment = X_ALIGN_BYTE_COUNT)
  {
  if(alignment <= 1)
    {
    return exp;
    }

  const xptrdiff bitmask = (xptrdiff)alignment - 1;
  const xptrdiff bits = ((xptrdiff)exp)&bitmask;

  const xptrdiff offset = (xptrdiff)alignment - bits;

  T aligned = offsetBy(exp, offset);

  return aligned;
  }


class ResourceDescription;

template <typename T> struct ResourceDescriptionTypeHelper
  {
  typedef typename std::aligned_storage<sizeof(T), std::alignment_of<T>::value>::type Storage;
  static ResourceDescription createFor();
  };

class ResourceDescription
  {
XProperties:
  XProperty(xsize, size, setSize);
  XProperty(xsize, alignment, setAlignment);

public:
  ResourceDescription()
    : _size(0),
      _alignment(0)
    {
    }

  ResourceDescription(xsize s, xsize a)
    : _size(s),
      _alignment(a)
    {
    }

  ResourceDescription operator+(const ResourceDescription &desc) const
    {
    ResourceDescription newDesc(*this);
    newDesc._size = Eks::roundToAlignment(_size, desc.alignment());
    newDesc._size += desc.size();
    return newDesc;
    }

  xsize allocatedSize() const
    {
    return _size + _alignment;
    }
  };

class Resource
  {
public:
  Resource(void *rsc = nullptr) : _resource(rsc)
    {
    }

  template <typename T> static Resource destroy(T *t)
    {
    ((T*)t)->~T();
    return Eks::Resource((T*)t);
    }

  Resource align(const ResourceDescription &desc) const
    {
    Resource rsc(Eks::roundToAlignment(_resource, desc.alignment()));
    xAssertIsSpecificAligned(rsc._resource, desc.alignment());
    return rsc;
    }

  Resource increment(xsize s) const
    {
    return Resource(static_cast<xuint8*>(_resource) + s);
    }

  Resource alignAndIncrement(const ResourceDescription &rsc, Resource* next) const
    {
    Resource ths(Eks::roundToAlignment(_resource, rsc.alignment()));
    *next = ths.increment(rsc.size());
    return ths;
    }

  template <typename T> T *create() const
    {
    return new(_resource) T();
    }
  template <typename T, typename A> T *create(A&& a) const
    {
    return new(_resource) T(a);
    }

  void *data() const { return _resource; }

private:
  void *_resource;
  };

template <typename T>
    ResourceDescription ResourceDescriptionTypeHelper<T>::createFor()
  {
  return ResourceDescription(sizeof(T), AlignmentOf<T>::Alignment);
  }
}

#endif // XRESOURCEDESCRIPTION_H
