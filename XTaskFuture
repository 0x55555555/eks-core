#ifndef XFUTURE_H
#define XFUTURE_H

#include "XGlobal"

namespace Eks
{

template <typename Result> class Task;

namespace detail
{

template <typename Fn, typename Arg, typename Result> class ContinuationTaskImpl
  {
  static Task<Result> create(const Task<Arg> &arg, const Fn &fn);
  };

template <typename Fn,
          typename Arg> class ContinuationTask
  {
public:
  typedef typename std::result_of<Fn(Arg)>::type Result;
  typedef typename Task<Result> TaskType;

  static TaskType create(const Task<Arg> &arg, const Fn &fn);
  };

template <typename Derived> class TaskBase
  {
public:
  template <typename OthResult>
  Task<void> whenBoth(const Task<OthResult> &oth)
    {
    (void)oth;
    return Task<void>();
    }

  template <typename OthResult>
  Task<void> operator&&(const Task<OthResult> &oth)
    {
    return whenBoth(oth);
    }
  };
}

template <typename Result> class Task : public detail::TaskBase<Task<void>>
  {
public:
  Task(const Result& re) : _result(re)
    {
    }

  template <typename Fn>
      typename detail::ContinuationTask<Fn, Result>::TaskType then(const Fn &fn) const
    {
    return detail::ContinuationTask<Fn, Result>::create(*this, fn);
    }

  const Result &result() const { return _result; }

private:
  Result _result;
  };

template <> class Task<void> : public detail::TaskBase<Task<void>>
  {
public:
  template <typename Fn>
      typename detail::ContinuationTask<Fn, void>::TaskType then(const Fn &fn) const
    {
    return detail::ContinuationTask<Fn, void>::create(*this, fn);
    }
  };

namespace detail
{
template <typename Fn> class ContinuationTaskImpl<Fn, void, void>
  {
  static Task<void>
      create(const Task<void> &arg, const Fn &fn)
    {
    fn();
    return TaskType<void>();
    }
  };

template <typename Fn, typename Arg> class ContinuationTaskImpl<Fn, Arg, void>
  {
  static Task<void>
      create(const Task<Arg> &arg, const Fn &fn)
    {
    fn(arg.result());
    return TaskType<void>();
    }
  };

template <typename Fn, typename Result> class ContinuationTaskImpl<Fn, void, Result>
  {
  static Task<Result>
      create(const Task<void> &arg, const Fn &fn)
    {
    Result res = fn();
    return TaskType<Result>(res);
    }
  };

template <typename Fn, typename Arg, typename Result>
    Task<Result>
    ContinuationTaskImpl<Fn, Arg, Result>::create(const Task<Arg> &arg, const Fn &fn)
  {
  Result res = fn(arg.result());
  return TaskType<Result>(res);
  }

template <typename Fn, typename Arg>
    typename ContinuationTask<Fn, Arg>::TaskType
    create(const Task<Arg> &arg, const Fn &fn)
  {
  ContinuationTaskImpl::create<Fn, Arg, Result>(arg, fn);
  }

}

}

#endif // XFUTURE_H
