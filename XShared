#ifndef XSHARED_H
#define XSHARED_H

#include <atomic>
#include "XTypedAllocator"

namespace Eks
{

namespace detail
{
class SharedData
  {
public:
  SharedData() : _ref(0) { }

private:
  mutable std::atomic<xuint32> _ref;

  template <typename T> friend class SharedPointer;
  template <typename T> friend class ConstSharedPointer;
  };
}

template <typename T,
          typename Alloc=TypedAllocator<T> > class ConstSharedPointer
    : Alloc
  {
public:
  ConstSharedPointer()
    : _ptr(0)
    {
    }

  explicit ConstSharedPointer( const detail::SharedData *ptr )
      : _ptr(const_cast<detail::SharedData*>(ptr))
    {
    xAssert(_ptr);
    ++_ptr->_ref;
    }

  ConstSharedPointer( const ConstSharedPointer<T> &cpy )
      : _ptr(cpy._ptr)
    {
    if(_ptr)
      {
      ++_ptr->_ref;
      }
    }

  ~ConstSharedPointer()
    {
    clear();
    }

  ConstSharedPointer<T> &operator=( const ConstSharedPointer<T> &cpy )
    {
    asign(cpy.ptr());
    }

  void clear()
    {
    if(_ptr && !(--_ptr->_ref))
      {
      allocator()->destroy(_ptr);
      _ptr = 0;
      }
    }

  void assign(const T *data)
    {
    clear();

    _ptr = cpy._ptr;
    if(_ptr)
      {
      ++_ptr->_ref;
      }
    }

  const T &operator *() const { return *ptr(); }

  const T *operator->() const { return ptr(); }

  const T *ptr() const { return static_cast<const T*>(_ptr); }
  const T *constPtr() const { return static_cast<const T*>(_ptr); }

protected:
  void dedtach()
    {
    if(_ptr && _ptr->_ref > 1)
      {
      Eks::AllocatorBase *alloc = allocator();
      _ptr = alloc->create<T>(*constPtr());
      }
    }

  AllocatorBase *allocator()
    {
    return this;
    }

  detail::SharedData *_ptr;
  };

template <typename T,
          typename Alloc=TypedAllocator<T> > class SharedPointer
    : public ConstSharedPointer<T, Alloc>
  {
public:
  SharedPointer()
    {
    }

  explicit SharedPointer(detail::SharedData *ptr)
    : ConstSharedPointer<T, Alloc>(ptr)
    {
    }

  SharedPointer(const SharedPointer<T> &cpy)
    : ConstSharedPointer(cpy)
    {
    }

  SharedPointer<T> &operator=(const SharedPointer<T> &cpy)
    {
    assign(cpy.ptr());
    }

  T &operator *() { detach(); return *ptr(); }
  const T &operator *() const { return *ptr(); }

  T *operator->() { detach(); return ptr(); }
  const T *operator->() const { return ptr(); }

  T *ptr() { detach(); return static_cast<T*>(_ptr); }
  const T *ptr() const { return static_cast<T*>(_ptr); }
  const T *constPtr() const { return static_cast<T*>(_ptr); }

private:
  SharedPointer(const ConstSharedPointer<T, Alloc> &cpy);
  SharedPointer &operator=(const ConstSharedPointer<T, Alloc> &);
  };

#endif // XSHARED_H
