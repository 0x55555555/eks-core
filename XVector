#ifndef XVECTOR_H
#define XVECTOR_H

#include "XGlobal"
#include "XAssert"
#include "XAllocatorBase"
#include "XTypedAllocator"
#include <algorithm>

namespace Eks
{

namespace detail
{

template <typename T, xsize Size, typename Alloc> class VectorStorage : public Alloc
  {
public:
  VectorStorage(const Alloc& a)
      : Alloc(a),
        _first(data),
        _last(data+Size),
        _end(data)
    {
    }

  bool isUsingEmbeddedStorage() const { return _first == data; }

  // the first member of the vector
  T *_first;
  // the element one past the capasity.
  T *_last;
  // the element one past the end of the active elements
  T *_end;

private:
  T data[Size];
  };

template <typename T, typename Alloc> class VectorStorage<T, 0, Alloc> : public Alloc
  {
public:
  VectorStorage(const Alloc& a)
      : Alloc(a),
        _first(0),
        _last(0),
        _end(0)
    {
    }

  bool isUsingEmbeddedStorage() const { return false; }

  // the first member of the vector
  T *_first;
  // the element one past the capasity.
  T *_last;
  // the element one past the end of the active elements
  T *_end;
  };
}

template <typename T,
          xsize PreallocatedSize = 0,
          typename Alloc = TypedAllocator<T> >
  class Vector
    : private detail::VectorStorage<T, PreallocatedSize, Alloc>
  {
public:
  typedef detail::VectorStorage<T, PreallocatedSize, Alloc> ThisBase;
  typedef Vector<T, PreallocatedSize, Alloc> ThisType;
  typedef xsize size_type;
  typedef T* iterator;
  typedef const T* const_iterator;

  Vector(const Alloc &alloc=Alloc())
      : ThisBase(alloc)
    {
    }

  template <typename X, xsize Pre, typename AllocX>
    Vector(const Vector<X, Pre, AllocX> &v, const Alloc &alloc=Alloc())
      : ThisBase(alloc)
    {
    resizeAndCopy(v.size(), v.begin());
    }

  template <typename X, xsize Pre, typename AllocX>
    Vector(Vector<X, Pre, AllocX> &&v, const Alloc &alloc=Alloc())
      : ThisBase(alloc)
    {
    swap(v);
    }

  explicit Vector(size_type size, const T& t, const Alloc &alloc=Alloc())
      : ThisBase(alloc)
    {
    resize(size, t);
    }

  ~Vector()
    {
    clear();
    squeeze();
    xAssert(_first == 0);
    }

  size_type size() const
    {
    return _end - _first;
    }

  size_type capacity() const
    {
    return _last - _first;
    }

  T &front()
    {
    xAssert(_first);
    return *_first;
    }

  const T &front() const
    {
    xAssert(_first);
    return *_first;
    }

  T &back()
    {
    xAssert(_end-1);
    return *(_end-1);
    }

  const T &back() const
    {
    xAssert(_end-1);
    return *(_end-1);
    }

  T *data()
    {
    return _first;
    }

  const T *data() const
    {
    return _first;
    }

  ThisType& operator<<(T &&t)
    {
    pushBack(t);
    return *this;
    }

  ThisType& operator<<(const T &t)
    {
    pushBack(t);
    return *this;
    }

  template <typename VecX>
  ThisType& operator+=(const VecX &t)
    {
    append(t);
    return *this;
    }

  iterator begin()
    {
    return _first;
    }

  iterator end()
    {
    return _end;
    }

  const_iterator begin() const
    {
    return _first;
    }

  const_iterator end() const
    {
    return _end;
    }

  const_iterator cbegin() const
    {
    return _first;
    }

  const_iterator cend() const
    {
    return _end;
    }

  void reserve(size_type newCapacity)
    {
    if(newCapacity <= capacity())
      {
      return;
      }

    const size_type s = size();
    const size_type oldCapacity = capacity();

    const size_type newBestCapacity = bestCapacity(newCapacity);

    T *newData = allocate(newBestCapacity);

    swap(newData, newData+s, _first);

    // destroy the old data
    for(size_type i = 0; i < s; ++i)
      {
      destroy(_first+i);
      }

    // always destroy the old data if it existed
    if(_first && !isUsingEmbeddedStorage())
      {
      deallocate(_first, oldCapacity);
      }

    _first = newData;
    _end = _first + s;
    _last = _first + newBestCapacity;
    }

  void squeeze()
    {
    if(_last == _end)
      {
      return;
      }

    const size_type s = size();
    const size_type newCapacity = s;

    T *oldData = _first;
    bool shouldDestroy = oldData && !isUsingEmbeddedStorage();
    xsize oldCapacity = capacity();

    if(s)
      {
      T *newData = allocate(newCapacity);

      // copy the new elements
      copy(newData, newData+s, _first);

      // destroy the old data
      for(size_type i = 0; i < s; ++i)
        {
        destroy(oldData+i);
        }

      _first = newData;
      _last = _end = _first + s;
      }
    else
      {
      // no old size, just reset pointers
      _last = _end = _first = 0;
      }

    // always destroy the old data if it existed
    if(shouldDestroy)
      {
      deallocate(oldData, oldCapacity);
      }
    }

  void resize(size_type newSize, const T &val = T())
    {
    size_type s = size();

    // destroy extra members
    for(size_type i = newSize; i < s; ++i)
      {
      destroy(&at(i));
      }

    // adjust the end
    _end = _first + xMin(s, newSize);

    // now expand, copying the needed members
    reserve(newSize);

    // adjust the new end
    _end = _first + newSize;

    // construct the extra members
    for(size_type i = s; i < newSize; ++i)
      {
      construct(&at(i), val);
      }
    }

  template <typename It>
      void resizeAndCopy(size_type newSize, It val)
    {
    size_type s = size();

    // destroy extra members
    for(size_type i = newSize; i < s; ++i)
      {
      destroy(&at(i));
      }

    // adjust the end
    _end = _first + xMin(s, newSize);

    // now expand, copying the needed members
    reserve(newSize);

    // adjust the new end
    _end = _first + newSize;

    // construct the extra members
    for(size_type i = s; i < newSize; ++i, ++val)
      {
      construct(&at(i), *val);
      }
    }

  void clear()
    {
    resize(0);
    }

  bool compare(const T *other, size_type count, size_type start=0) const
    {
    if(start + count >= length())
      {
      return false;
      }

    const T *ths = data() + start;

    return memcmp(ths, other, sizeof(T) * count) == 0;
    }

  size_type length() const { return size(); }

  size_type indexOf(const T &t, size_type from) const
    {
    const_iterator it = begin() + from;
    const_iterator found = std::find(it, cend(), t);

    if(found == end())
      {
      return X_SIZE_SENTINEL;
      }
    return found - begin();
    }

  size_type indexOf(const T *t, size_type count, size_type from) const
    {
    xAssert(count >= 0);
    size_type index = indexOf(t[0], from);
    for(size_type i = 1; i < count; ++i)
      {
      if(at(index + i) != t[i])
        {
        return indexOf(t, count, index+1);
        }
      }

    return index;
    }

  void popBack()
    {
    xAssert(_end);
    --_end;
    }

  void pushBack(const T &t)
    {
    const size_type s = size();
    if(s == capacity())
      {
      reserve(s + 1);
      }

    xAssert(_end < _last);
    construct(_end, t);
    _end++;
    }

  void pushBack(const T &&t)
    {
    const size_type s = size();
    if(s == capacity())
      {
      reserve(s + 1);
      }

    xAssert(_end < _last);
    construct(_end, t);
    _end++;
    }

  template <typename T> void append(T vals, size_type count)
    {
    resizeAndCopy(size() + count, vals);
    }

  template <typename Vec> void append(const Vec &vals)
    {
    resizeAndCopy(size() + vals.size(), vals.begin());
    }

  template <typename T>
      void copy(const iterator &begin, const iterator &end, T from)
    {
    for(iterator it = begin; it != end; ++it, ++from)
      {
      *it = *from;
      }
    }

  template <typename T>
      void swap(const iterator &begin, const iterator &end, T from)
    {
    for(iterator it = begin; it != end; ++it, ++from)
      {
      std::swap(*it, *from);
      }
    }

  template <typename X, xsize Pre, typename AllocX>
  void swap(Vector<X, Pre, AllocX> &oth)
    {
    if(oth._alloc == oth._alloc)
      {
      std::swap(_first, oth._first);
      std::swap(_last, oth._last);
      std::swap(_end, oth._end);
      }
    else
      {
      resizeAndCopy(oth.size(), oth.data());
      }
    }

  T &at(size_type i)
    {
    xAssert(i < size());
    return *(_first + i);
    }

  const T &at(size_type i) const
    {
    xAssert(i < size());
    return *(_first + i);
    }

  T &operator[](size_type i)
    {
    return at(i);
    }

  const T &operator[](size_type i) const
    {
    return at(i);
    }

  void setAllocator(const Alloc &a)
    {
    xAssert(_first == 0);
    allocator() = a;
    }

  Alloc &allocator()
    {
    return *this;
    }

  size_type bestCapacity(size_type s) const
    {
    const size_type expandExistingPolicy = 2;
    const size_type expandReservePolicy = 2;
    return xMax(s * expandExistingPolicy, size() * expandReservePolicy);
    }
  };

namespace detail
{
typedef StaticTypedAllocator<GlobalAllocator, int> testIntGSA;
typedef VectorStorage <int, 0, testIntGSA> testVectorStorage;

// this is important - a simple vector should only be three pointers
xCompileTimeAssert(sizeof(testVectorStorage) == sizeof(void *) * 3);
xCompileTimeAssert(sizeof(Vector <int, 0, testIntGSA>) == sizeof(testVectorStorage));

// a vector with preallocation should be more or less three pointers with the extra data appended
xCompileTimeAssert(sizeof(Vector <int, 6, testIntGSA>) == (sizeof(void *) * 3 + sizeof(int) * 6));

// and a vector with preallocation and an allocator should be only one extra pointer
xCompileTimeAssert(sizeof(Vector <int, 6, TypedAllocator<int> >)
                     == (sizeof(void *) * 3 + sizeof(void *) + sizeof(int) * 6));
}

}

#endif
