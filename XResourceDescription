#ifndef XRESOURCEDESCRIPTION_H
#define XRESOURCEDESCRIPTION_H

#include "XGlobal"
#include "XProperty"

namespace Eks
{

#define X_ALIGN_BYTE_COUNT 16

#define xAssertIsSpecificAligned(ptr, alignment) xAssert(Eks::isAligned(ptr, alignment), (xsize)ptr, alignment, ((xsize)(ptr)&(alignment-1)))
#define xAssertIsAligned(ptr) xAssertIsSpecificAligned(ptr, X_ALIGN_BYTE_COUNT)

template <typename T> struct AlignmentOf
  {
  enum
    {
    Alignment = std::alignment_of<T>::value
    };
  };

template <typename T> bool isAligned(T ptr, xsize alignment = X_ALIGN_BYTE_COUNT)
  {
  const xptrdiff bitmask = (xptrdiff)alignment - 1;
  const xsize ptrD = (xsize)ptr;

  return (ptrD&bitmask) == 0;
  }

template <typename T> T offsetBy(T d, xptrdiff by)
  {
  return (T)((xuint8*)d + by);
  }

template <typename T> inline T roundToAlignment(T exp, xsize alignment = X_ALIGN_BYTE_COUNT)
  {
  if(alignment <= 1)
    {
    return exp;
    }

  const xptrdiff bitmask = (xptrdiff)alignment - 1;
  const xptrdiff bits = ((xptrdiff)exp)&bitmask;

  const xptrdiff offset = (xptrdiff)alignment - bits;

  T aligned = offsetBy(exp, offset);

  return aligned;
  }


class ResourceDescription;

template <typename T> struct ResourceDescriptionTypeHelper
  {
  static ResourceDescription createFor();
  };

class ResourceDescription
  {
XProperties:
  XProperty(xsize, size, setSize);
  XProperty(xsize, alignment, setAlignment);

public:
  ResourceDescription()
    : _size(0),
      _alignment(0)
    {
    }

  ResourceDescription(xsize s, xsize a)
    : _size(s),
      _alignment(a)
    {
    }

  xsize allocatedSize() const
    {
    return _size + _alignment;
    }
  };

template <typename T>
    ResourceDescription ResourceDescriptionTypeHelper<T>::createFor()
  {
  return ResourceDescription(sizeof(T), AlignmentOf<T>::Alignment);
  }
}

#endif // XRESOURCEDESCRIPTION_H
