#ifndef XSHARED_H
#define XSHARED_H

#include <atomic>
#include "XTypedAllocator"

namespace Eks
{

template <typename T, typename Alloc> class ConstSharedPointer;
template <typename T, typename Alloc> class SharedPointer;

namespace detail
{
class SharedData
  {
public:
  SharedData() : _ref(0) { }
  SharedData(const SharedData &d) : _ref((xuint32)d._ref)
    {

    }

private:
  mutable std::atomic<xuint32> _ref;

  template <typename T, typename Alloc> friend class Eks::SharedPointer;
  template <typename T, typename Alloc> friend class Eks::ConstSharedPointer;
  };
}

template <typename T,
          typename Alloc=TypedAllocator<T> > class ConstSharedPointer
    : Alloc
  {
public:
  ConstSharedPointer()
    : _ptr(0)
    {
    }

  explicit ConstSharedPointer(const detail::SharedData *ptr, const Alloc &a = Alloc())
      : Alloc(a), _ptr(const_cast<detail::SharedData*>(ptr))
    {
    xAssert(_ptr);
    ++_ptr->_ref;
    }

  ConstSharedPointer(const ConstSharedPointer<T, Alloc> &cpy, const Alloc &a = Alloc())
      : Alloc(a), _ptr(cpy._ptr)
    {
    if(_ptr)
      {
      ++_ptr->_ref;
      }
    }

  ~ConstSharedPointer()
    {
    clear();
    }

  ConstSharedPointer<T> &operator=(const ConstSharedPointer<T> &cpy)
    {
    asign(cpy.ptr());
    }

  bool operator==(const ConstSharedPointer<T> &oth)
    {
    return _ptr == oth._ptr;
    }

  void clear()
    {
    if(_ptr && !(--_ptr->_ref))
      {
      allocator()->destroy(_ptr);
      _ptr = 0;
      }
    }

  void assign(T *cpy)
    {
    clear();

    if(cpy)
      {
      _ptr = cpy;
      ++_ptr->_ref;
      }
    }

  operator const bool() const { return ptr(); }
  operator const T *() const { return ptr(); }

  const T &operator *() const { return *ptr(); }

  const T *operator->() const { return ptr(); }

  const T *ptr() const { return static_cast<const T*>(_ptr); }
  const T *constPtr() const { return static_cast<const T*>(_ptr); }

protected:
  void detach()
    {
    if(_ptr && _ptr->_ref > 1)
      {
      Eks::AllocatorBase *alloc = allocator()->allocator();
      _ptr = alloc->create<T>(*constPtr());
      }
    }

  Alloc *allocator()
    {
    return this;
    }

  detail::SharedData *_ptr;
  };

template <typename T,
          typename Alloc=TypedAllocator<T> > class SharedPointer
    : public ConstSharedPointer<T, Alloc>
  {
public:
  SharedPointer()
    {
    }

  explicit SharedPointer(detail::SharedData *ptr, const Alloc &a = Alloc())
    : ConstSharedPointer<T, Alloc>(ptr, a)
    {
    }

  SharedPointer(const SharedPointer<T, Alloc> &cpy, const Alloc &a = Alloc())
    : ConstSharedPointer(cpy, a)
    {
    }

  SharedPointer<T> &operator=(const SharedPointer<T, Alloc> &cpy)
    {
    assign(cpy.ptr());
    return *this;
    }

  operator T *() { return ptr(); }

  T &operator *() { detach(); return *ptr(); }
  T &operator *() const { return *ptr(); }

  T *operator->() { detach(); return ptr(); }
  T *operator->() const { return ptr(); }

  T *ptr() { detach(); return static_cast<T*>(_ptr); }
  T *ptr() const { return static_cast<T*>(_ptr); }
  T *constPtr() const { return static_cast<T*>(_ptr); }

private:
  SharedPointer(const ConstSharedPointer<T, Alloc> &cpy);
  SharedPointer &operator=(const ConstSharedPointer<T, Alloc> &);
  };

template <typename T> Eks::SharedPointer<T, TypedAllocator<T>> AllocatorBase::createShared()
  {
  void *mem = alloc(sizeof(T), AlignmentOf<T>::Alignment);
  return Eks::SharedPointer<T, TypedAllocator<T>>(new(mem) T(), this);
  }

}

#endif // XSHARED_H
