#ifndef XEVENTLOGGER_H
#define XEVENTLOGGER_H

#include "XGlobal"
#include "XTime"
#include "XUniquePointer"
#include "XVector"
#include <atomic>


namespace Eks
{

class AllocatorBase;

class EKSCORE_EXPORT ThreadEventLogger
  {
XProperties:
  XROProperty(QThread *, thread);
  XProperty(ThreadEventLogger *, next, setNext);

public:
  class EKSCORE_EXPORT EventData
    {
  public:
    EventData();
    EventData(const EventData&);
    ~EventData();

    struct Location
      {
      QString file;
      xsize line;
      QString function;
      };
    xCompileTimeAssert(sizeof(Location) == sizeof(CodeLocation));

    void setLocation(const CodeLocation &loc);
    const CodeLocation &location() const;

    void setAllocatedLocation(const Location &loc);
    const Location &allocatedLocation() const;

    bool hasEmbeddedLocation() const { return _hasEmbeddedLocation; }
    bool hasAllocatedLocation() const { return _hasAllocatedLocation; }

    QString data;

  private:
    void clear();

    ResourceDescriptionTypeHelper<CodeLocation>::Storage _data;

    bool _hasEmbeddedLocation;
    bool _hasAllocatedLocation;
    };

  enum class EventType : xuint8
    {
    Begin,
    End,
    Moment
    };

  typedef xsize EventID;
  struct EventItem
    {
    Eks::Time time;
    EventType type;
    EventData data;
    EventID id;
    };
  typedef Eks::Vector<EventItem, 64> EventVector;

  ThreadEventLogger(QThread *thread, Eks::AllocatorBase *allocator);
  ~ThreadEventLogger();

  EventID beginDurationEvent(const EventData *);
  void endDurationEvent(EventID id);

  void momentEvent(const EventData *);

  EventVector *swapEventVector(EventVector *vec);

  void *operator new(size_t, void *w);
  void operator delete(void *ptr, void *);
  void operator delete(void* ptr);

private:
  EventItem *addAndLockItems();
  void unlockItems();

  Eks::AllocatorBase *_allocator;
  EventID _currentID;
  std::atomic<EventVector *> _events;
  EventVector *_lockedEvents;
  };

class EKSCORE_EXPORT EventLogger
  {
public:
  EventLogger(Eks::AllocatorBase *);
  ~EventLogger();

  ThreadEventLogger *threadLogger();

  class Watcher
    {
  public:
    virtual void onEvents(
        const QThread *thread,
        const ThreadEventLogger::EventVector &) = 0;
    };

  void setEventWatcher(Watcher *w);

  void syncCachedEvents();

  Eks::AllocatorBase *deleteThread(ThreadEventLogger *t);

private:
  class Impl;
  Eks::UniquePointer<Impl> _impl;
  };

#if X_EVENT_LOGGING_ENABLED

class EKSCORE_EXPORT ScopedEvent
  {
public:
  ScopedEvent(const CodeLocation &loc, const QString& data=QString());
  ~ScopedEvent();

private:
  ThreadEventLogger::EventID _id;
  };

# define X_EVENT_FUNCTION Eks::ScopedEvent _EVENT_##__LINE__(X_CURRENT_CODE_LOCATION)
# define X_EVENT_BLOCK(data) Eks::ScopedEvent _EVENT_##__LINE__(X_CURRENT_CODE_LOCATION, data)

#else

# define X_EVENT_FUNCTION
# define X_EVENT_BLOCK(data)

#endif

Q_DECLARE_METATYPE(ThreadEventLogger::EventData::Location)

}

#endif // XEVENTLOGGER_H
